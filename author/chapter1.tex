\chapter{The Role of Algorithms}
\section{Definitions}
\vspace*{0.2cm}\large\textbf{Algorithms}\\
An \textbf{algorithm} is a procedure used to solve a computational problem.
An algorithm takes some value as \textbf{input} and produce some value as \textbf{output}.
\\
Example: the \textbf{sorting problem}\\
\indent \textbf{input} : A sequence of $n$ numbers $<a_1,a_2\dots a_n>$\\
\indent \textbf{Output} : The sequence ordered from lowest to highest $<a'_{1},a'_{2}\dots a_n>$
\\
\indent Such sequence of inputs is called \textbf{instance} of the problem.\\
An algorithm is \textbf{correct} and \textbf{solve} the problem if for every input instance it ends with the correct output.\\
\indent \textbf{Sorting} is the only computational problem we can solve with algorithms, every problem we see is some sort of sorting.\\ 
\\
\vspace*{0.2cm}{\large\textbf{Data Structures}}\\ 
A \textbf{data structure} is a way to store and organize data that facilitate access and modification. 
\\\\
\vspace*{0.2cm}{\large\textbf{Complexity}}\\
When we talk about the complexity of an algorithm. There are two types.\\
\indent \textbf{Time Complexity} : How long the algorithm takes to produce the results. \\
\indent\textbf{Space Complexity} : How much storage space an algorithm needs.\\
\indent If not specified, complexity usually means time complexity.\\
Complexities are defined by a polynomial function of $n$, the number of inputs.
\\\\
\vspace*{0.2cm}{\large\textbf{Hard Problem}}\\ 
Hard problems are problems that we have no known efficient algorithms yet. They are also called NP-complete problems.\\
\indent What we learn in this book are all efficient algorithms \textbf{efficient algorithms} which has polynomial time complexities. 

